<!doctype html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vinbot ‚Äì find vin p√• sekunder</title>
  <meta name="description" content="Find den perfekte vin til mad, hum√∏r eller lejlighed. Vinbot viser konkrete flasker med billeder, priser og links til de bedste butikker." />
  <link rel="stylesheet" href="/assets/styles.css" />
  <link rel="icon" type="image/png" href="/assets/vinbot-logo.png" />
</head>
<body>
  <!-- Header partial -->
  <div id="header"></div>

  <header class="hero">
    <h1>Find vin p√• sekunder</h1>
    <p>Fort√¶l hvad du er i hum√∏r til ‚Äì <strong>drue</strong>, <strong>mad</strong>, <strong>pris</strong> eller <strong>lejlighed</strong>. Vinbot guider dig til de bedste flasker og butikker.</p>

    <div class="search-wrap">
      <div class="search">
        <div class="icon">üîé</div>
        <input id="q" placeholder="fx ‚Äúbarolo til b√∏f under 150 kr‚Äù eller ‚Äúost og hygge‚Äù" autocomplete="off" autofocus
               onkeydown="if(event.key==='Enter'){doSearch()}" />
        <button class="btn-primary" id="searchBtn" onclick="doSearch()">S√∏g</button>
      </div>
      <p class="search-hint">Tryk <kbd>Enter</kbd> eller brug mobilens ‚ÄúS√∏g‚Äù</p>
    </div>
  </header>

  <main class="wrap">
    <!-- STATUS -->
    <div id="status" class="status"></div>

    <!-- AI-opf√∏lgning -->
    <section id="followup" class="followup hidden" aria-live="polite"></section>

    <!-- Resultater -->
    <section class="grid" id="results" aria-live="polite"></section>
  </main>

  <!-- Footer partial -->
  <div id="footer"></div>

  <script>
    // Load partials
    (async()=> {
      const [h,f] = await Promise.all([
        fetch("/partials/header.html",{cache:"no-store"}).then(r=>r.text()),
        fetch("/partials/footer.html",{cache:"no-store"}).then(r=>r.text()),
      ]);
      document.getElementById("header").innerHTML = h;
      document.getElementById("footer").innerHTML = f;
    })();
  </script>

  <script>
    // ---------- Intent & synonymer ----------
    const INTENT = {
      // mad
      ost:["portvin","riesling","chardonnay","sauternes"],
      pizza:["chianti","barbera","primitivo"],
      b√∏f:["barolo","cabernet sauvignon","syrah"],
      oksek√∏d:["cabernet","syrah","malbec"],
      lam:["syrah","rioja","ribera del duero"],
      fisk:["riesling","chablis","albari√±o"],
      sushi:["riesling","sauvignon blanc","cr√©mant"],
      tapas:["rioja","garnacha","cava"],
      dessert:["sauternes","portvin","moscato"],
      // hum√∏r/lejlighed
      sommer:["ros√©","sauvignon blanc","cr√©mant"],
      terrasse:["ros√©","cava","prosecco"],
      hygge:["primitivo","zinfandel","malbec"],
      romantisk:["pinot noir","champagne"]
    };
    const EQUIV = {
      barolo:["nebbiolo"], nebbiolo:["barolo"],
      rioja:["tempranillo"], tempranillo:["rioja"],
      ribera:["ribera del duero","tempranillo"], "ribera del duero":["ribera","tempranillo"],
      shiraz:["syrah"], syrah:["shiraz"],
      rose:["ros√©"], "ros√©":["rose"],
      cab:["cabernet","cabernet sauvignon"], cabernet:["cab","cabernet sauvignon"], "cabernet sauvignon":["cab","cabernet"]
    };

    // ---------- Filter state (AI-opf√∏lgning) ----------
    const state = {
      baseTerms: [],     // termer fra brugerens input
      filters: {         // udfyldes via chips
        farve: null,     // "r√∏d","hvid","ros√©","bobler"
        stil: [],        // "let","frugtig","kraftig","t√∏r","s√∏d"
        pris: null,      // tal (max)
        land: [],        // fx "italien","frankrig","spanien"
        anledning: null, // "hygge","romantisk","sommer","fest"
        mad: null        // "ost","pizza","b√∏f"...
      }
    };

    // mapping fra chips -> s√∏getermer
    const CHIP_MAP = {
      farve: {
        "r√∏d":["barolo","nebbiolo","cabernet","syrah","malbec","tempranillo","zinfandel","primitivo","pinot noir"],
        "hvid":["chardonnay","riesling","sauvignon blanc","chablis","albari√±o","arneis"],
        "ros√©":["ros√©","provencalsk ros√©"],
        "bobler":["champagne","cr√©mant","cava","prosecco"]
      },
      stil: {
        "let":["pinot noir","gamay","bardolino","valpolicella"],
        "frugtig":["primitivo","zinfandel","malbec"],
        "kraftig":["barolo","amarone","cabernet sauvignon","syrah"],
        "t√∏r":["riesling trocken","chablis","albari√±o","fiano"],
        "s√∏d":["sauternes","moscato","portvin"]
      },
      land: {
        "italien":["barolo","chianti","amarone","prosecco","arneis"],
        "frankrig":["bourgogne","chablis","c√¥tes du rh√¥ne","cr√©mant","champagne"],
        "spanien":["rioja","ribera del duero","albari√±o","cava"],
        "tyskland":["riesling","sp√§tburgunder"],
        "portugal":["portvin","vinho verde"]
      },
      anledning: {
        "sommer":["ros√©","sauvignon blanc","cr√©mant"],
        "hygge":["primitivo","zinfandel","malbec"],
        "romantisk":["pinot noir","champagne"],
        "fest":["cava","prosecco","cr√©mant"]
      }
    };

    function deriveTermsFromInput(raw){
      const q = (raw||"").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
      const S=new Set();
      // mad/hum√∏r
      Object.keys(INTENT).forEach(k=>{ if(q.includes(k)) INTENT[k].forEach(v=>S.add(v)); });
      // direkte tokens + √¶kvivalenter
      q.split(/\s+/).forEach(t=>{ if(!t) return; S.add(t); (EQUIV[t]||[]).forEach(x=>S.add(x)); });
      // budget
      let max=null; const m=q.match(/(?:under|max)\s*(\d{2,4})\s*kr/); if(m) max=parseInt(m[1],10);
      if(/billig|budget/.test(q)) max=Math.min(max??9999,100);
      return {terms:[...S], max};
    }

    function deriveTermsFromFilters(){
      const f = state.filters;
      const extra = new Set();

      if (f.farve && CHIP_MAP.farve[f.farve]) CHIP_MAP.farve[f.farve].forEach(t=>extra.add(t));
      f.stil.forEach(s => { (CHIP_MAP.stil[s]||[]).forEach(t=>extra.add(t)); });
      f.land.forEach(l => { (CHIP_MAP.land[l]||[]).forEach(t=>extra.add(t)); });
      if (f.anledning && CHIP_MAP.anledning[f.anledning]) CHIP_MAP.anledning[f.anledning].forEach(t=>extra.add(t));
      if (f.mad && INTENT[f.mad]) INTENT[f.mad].forEach(t=>extra.add(t));

      // to-vejs √¶kvivalenter
      [...extra].forEach(t => (EQUIV[t]||[]).forEach(x=>extra.add(x)));
      return [...extra];
    }

    async function doSearch(fromChip=false){
      const q = document.getElementById('q').value.trim();
      if (!fromChip) {
        // ny grunds√∏gning -> nulstil filter-state (behold dog feltet pris hvis brugeren skrev det)
        state.filters = { farve:null, stil:[], pris:null, land:[], anledning:null, mad:null };
      }

      const base = deriveTermsFromInput(q);
      state.baseTerms = base.terms;
      if (base.max != null) state.filters.pris = base.max;

      const refined = deriveTermsFromFilters();
      const finalTerms = Array.from(new Set([...state.baseTerms, ...refined]));

      // UI
      const $status = document.getElementById("status");
      const $res = document.getElementById("results");
      $status.innerHTML = `<div class="msg info"><span class="spinner"></span> S√∏ger i butikker‚Ä¶</div>`;
      $res.innerHTML = `<div class="msg info"><span class="spinner"></span> Finder flasker‚Ä¶</div>`;

      // kald api
      const params = new URLSearchParams();
      params.set("q", finalTerms.join(" "));
      if (state.filters.pris != null) params.set("max", String(state.filters.pris));

      const r = await fetch(`/api/search?${params.toString()}`, {cache:"no-store"});
      const data = await r.json();

      // STATUS
      const meta = data.meta || {};
      if (data.source === "feed") {
        const bits = [];
        bits.push(`Viser ${data.products?.length ?? 0} flasker`);
        if (meta.feeds_ok != null && meta.feeds_total != null) bits.push(`fra ${meta.feeds_ok} / ${meta.feeds_total} butikker`);
        if (meta.feeds_failed) bits.push(`(${meta.feeds_failed} fejlede)`);
        $status.innerHTML = `<div class="msg info">${bits.join(" ¬∑ ")}</div>`;
      } else if (data.source === "fallback") {
        $status.innerHTML = `<div class="msg err">Ingen direkte feed-tr√¶f. Viser butikssider uden pris.</div>`;
      } else {
        $status.innerHTML = `<div class="msg err">Ingen resultater.</div>`;
      }

      // RENDER RESULTATER
      const products = data.products || [];
      if (!products.length) {
        document.getElementById("results").innerHTML = `<div class="msg err">Ingen rigtige produkter endnu.</div>`;
      } else {
        document.getElementById("results").innerHTML = products.map(p => `
          <a class="card product outbound" href="${p.url}" target="_blank" rel="nofollow sponsored noopener" data-label="${p.title}">
            <div class="card-media">${p.image ? `<img src="${p.image}" alt="${p.title}">` : `<div class="img-fallback">üç∑</div>`}</div>
            <div class="card-body">
              <h3>${p.title}</h3>
              <div class="badges">
                ${p.price!=null ? `<span class="badge">${Number(p.price).toLocaleString("da-DK",{style:"currency",currency:"DKK"})}</span>` : ""}
                ${p.merchant ? `<span class="badge">${p.merchant}</span>` : ""}
              </div>
            </div>
          </a>
        `).join("");
      }

      // RENDER AI-OPF√òLGNING (chips)
      renderFollowup(q, products.length);
    }

    function renderFollowup(query, resultCount){
      const $f = document.getElementById("followup");

      // Vis opf√∏lgning n√•r: 1) f√∏rste s√∏gning, eller 2) mange generiske termer, eller 3) f√• resultater
      const generic = /r√∏dvin|hvidvin|ros[e√©]|bobler|vin|ost|pizza|k√∏d|b√∏f|mad|sommer|hygge/i.test(query);
      const shouldAsk = generic || resultCount < 8;

      if (!shouldAsk) { $f.classList.add("hidden"); $f.innerHTML=""; return; }

      const chips = (group, items, multi=false) => `
        <div class="chip-group" data-group="${group}" data-multi="${multi}">
          <div class="chip-title">${group}</div>
          <div class="chip-row">
            ${items.map(label => `<button class="chip ${isActive(group,label) ? 'on':''}" data-value="${label}">${label}</button>`).join("")}
          </div>
        </div>`;

      const ui = `
        <div class="followup-inner">
          <h2>Hj√¶lp mig med at ramme smagen</h2>
          <div class="chip-grid">
            ${chips("farve", ["r√∏d","hvid","ros√©","bobler"], false)}
            ${chips("stil", ["let","frugtig","kraftig","t√∏r","s√∏d"], true)}
            ${chips("land", ["italien","frankrig","spanien","tyskland","portugal"], true)}
            ${chips("anledning", ["sommer","hygge","romantisk","fest"], false)}
            ${chips("mad", ["ost","pizza","b√∏f","lam","fisk","sushi","tapas","dessert"], false)}
          </div>
          <div class="chip-actions">
            <div class="price-wrap">
              <label for="ai-price">Maks pris</label>
              <input id="ai-price" type="number" min="30" step="10" placeholder="fx 150" value="${state.filters.pris ?? ''}">
            </div>
            <button id="applyChips" class="btn-primary">Opdater</button>
            <button id="clearChips" class="btn-soft">Nulstil</button>
          </div>
        </div>
      `;

      $f.innerHTML = ui;
      $f.classList.remove("hidden");

      // events
      $f.querySelectorAll(".chip").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const group = btn.closest(".chip-group").dataset.group;
          const multi = btn.closest(".chip-group").dataset.multi === "true";
          toggleChip(group, btn.dataset.value, multi);
          btn.classList.toggle("on");
          // auto-opdater hurtigt n√•r single-valg (farve/anledning/mad)
          if (!multi) doSearch(true);
        });
      });
      $f.querySelector("#applyChips").addEventListener("click", ()=>{
        const v = document.getElementById("ai-price").value.trim();
        state.filters.pris = v ? Math.max(0, parseInt(v,10)) : null;
        doSearch(true);
      });
      $f.querySelector("#clearChips").addEventListener("click", ()=>{
        state.filters = { farve:null, stil:[], pris:null, land:[], anledning:null, mad:null };
        doSearch(true);
      });
    }

    function isActive(group, label){
      const f = state.filters;
      if (Array.isArray(f[group])) return f[group].includes(label);
      return f[group] === label;
    }
    function toggleChip(group, label, multi){
      const f = state.filters;
      if (multi) {
        const arr = Array.isArray(f[group]) ? f[group] : [];
        const i = arr.indexOf(label);
        if (i === -1) arr.push(label); else arr.splice(i,1);
        f[group] = arr;
      } else {
        f[group] = (f[group] === label) ? null : label;
      }
    }

    // GA4 outbound tracking (valgfri)
    document.addEventListener('click', (e)=>{
      const a = e.target.closest('a.outbound'); if(!a) return;
      if (typeof gtag === 'function'){
        gtag('event','outbound_click',{event_category:'affiliate',event_label:a.dataset.label || a.href});
      }
    });

    // kickstart: ingen s√∏gning p√• load; bruger skriver selv el. klikker chips
  </script>
</body>
</html>
